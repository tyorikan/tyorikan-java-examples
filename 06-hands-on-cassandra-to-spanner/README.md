# ハンズオン: JavaアプリケーションをCassandraからCloud Spannerへ移行する

このリポジトリは、Java Spring BootアプリケーションをApache CassandraからGoogle Cloud Spannerへ移行するプロセスをステップバイステップで学ぶハンズオンラボです。

## シナリオ

このハンズオンでは、歌手(Singer)、そのアルバム(Album)、そしてアルバムの曲(Track)を管理するシンプルな音楽カタログアプリケーションを扱います。この階層的なデータモデル (`Singer` -> `Album` -> `Track`) は、CassandraとSpannerにおけるデータモデリングとクエリのアプローチの違いを明確にするために、意図的に選択されました。

## ハンズオンの構成

このラボは2つの主要なステップに分かれており、それぞれが専用のディレクトリに配置されています。

### [Step 1: 移行元のCassandraアプリケーション](./step-01-java-cassandra/)

ここが私たちの出発点です。これは、Spring Data Cassandraを使用してCassandraデータベースと連携する、完全に動作するSpring Bootアプリケーションです。関連データを別々のテーブルでモデリングし、それらを結合するためにアプリケーション層で複数のクエリを発行する必要がある、という一般的な方法をデモンストレーションします。

**[Step 1から始める](./step-01-java-cassandra/README.md)**

### [Step 2: 移行先のSpannerアプリケーション](./step-02-java-spanner/)

こちらが最終的な、移行が完了したアプリケーションです。Step 1のロジックをリファクタリングし、Google Cloud Spannerを使用するように変更します。ここでの重要なポイントは、親子関係のデータを扱うアプリケーションコードを劇的に簡素化する **Spannerのインターリーブテーブル** を使用することです。

**[Step 2へ進む](./step-02-java-spanner/README.md)**

## 学習目標

このハンズオンを完了することで、以下のことを学びます：

- Cassandraで階層データをモデリングする方法
- Spannerのインターリーブテーブルを使用して同じデータをモデリングする方法
- `spring-boot-starter-data-cassandra` と `spring-cloud-gcp-starter-data-spanner` の実践的な違い
- JavaアプリケーションにおけるSpannerの強力な整合性とリレーショナル機能の利点
- データベースの移行が、よりシンプルで効率的なアプリケーションコードにどのようにつながるか

---

## 詳細解説: CassandraからSpannerへの移行で知るべきこと

このセクションでは、Cassandraに馴染みのない方でも、Spannerへの移行を理解するために必要なCassandraの基本的な特徴と、Spannerとのアーキテクチャや設計思想の違いについて詳しく解説します。

### 1. Apache Cassandraの基本: 「クエリ駆動」のデータモデリング

Cassandraは、高い可用性とスケーラビリティを実現するために設計された**分散型NoSQLデータベース**です。その最大の特徴は、リレーショナルデータベース（RDB）とは全く異なるデータモデリングのアプローチにあります。

#### アーキテクチャの要点
- **マスターレス・アーキテクチャ**: 全てのノードが同等の役割を担い、単一障害点がありません。これにより、一部のノードがダウンしてもサービスを継続できます。
- **パーティションキー**: データの分散場所を決める最も重要な要素です。SQLの`WHERE`句でパーティションキーを指定することで、Cassandraは広大なクラスタの中からどのノードにデータがあるかを効率的に特定します。
- **結果整合性**: 書き込みはすぐに全ノードに反映されるわけではなく、最終的に（Eventually）データが一致する状態を目指します。これにより高速な書き込みを実現しますが、アプリケーション側で「書き込んだはずのデータが読めない」といった状況を考慮する必要があります。

#### クエリ駆動モデリングと非正規化
Cassandraの設計で最も重要な原則は**「まずクエリありき」**です。RDBのように正規化されたテーブルを設計し、`JOIN`を使って柔軟にデータを取得する、という考え方はありません。

代わりに、**「アプリケーションがどのようなクエリでデータを取得したいか」**を最初に全て洗い出し、そのクエリが最速で実行できるようにテーブルを設計します。

これは多くの場合、**非正規化（データの意図的な重複）** を伴います。

**ハンズオンでの具体例 (`step-01-java-cassandra`):**
このハンズオンでは、ユーザーの注文履歴を取得する要件があります。
- 「ある**ユーザー**が購入した**アルバム**一覧」を取得したい
- 「ある**アルバム**を購入した**ユーザー**一覧」を取得したい

Cassandraでは`JOIN`が使えないため、これらのクエリを効率的に実行するために、同じ注文データ（誰が、何を、いつ買ったか）を**2つの異なるテーブル**に保存しています。

1.  `orders_by_user`: **ユーザーID**をパーティションキーとし、ユーザーごとの注文を取得するテーブル。
2.  `orders_by_album`: **アルバムID**をパーティションキーとし、アルバムごとの購入者を取得するテーブル。

このように、1つの事実（注文）を、異なるアクセスパターン（クエリ）のために複数のテーブルに複製するのが、Cassandraの典型的なモデlingです。アプリケーションは、目的に応じて適切なテーブルをクエリし、必要であればコード上でデータを結合（マージ）します。

### 2. Cloud Spanner: RDBのスケーラビリティと強整合性の両立

Spannerは、RDBの使いやすさ（リレーショナルモデル、SQL、強整合性）と、NoSQLの持つグローバルなスケーラビリティを両立させた、Google Cloudが提供するユニークなデータベースです。

#### Cassandraとの主な違い
| 特徴 | Apache Cassandra | Google Cloud Spanner |
| :--- | :--- | :--- |
| **データモデル** | 非正規化 / `JOIN`なし | **正規化されたリレーショナルモデル** / **SQL `JOIN`あり** |
| **整合性** | 結果整合性 | **強整合性** (常に最新のデータを読み書きできる) |
| **スキーマ** | クエリ駆動 (柔軟だが重複が多い) | **リレーショナルスキーマ** (RDBと同様) |
| **主要機能** | 高速な書き込み、高い可用性 | **グローバルな水平スケール**、**トランザクションの強整合性** |

#### Spannerへの移行の核心: インターリーブテーブル
Spannerへの移行で最も大きなメリットを享受できるのが、**インターリーブテーブル（Interleaved Tables）**という機能です。

これは、親子関係にあるテーブルのデータを、物理的に同じ場所に格納する機能です。

**ハンズオンでの具体例 (`step-02-java-spanner`):**
この音楽アプリケーションのデータは、明確な親子関係を持っています。
`Singers` (親) -> `Albums` (子) -> `Tracks` (孫)

Spannerでは、この関係をスキーマで定義できます。
- `Albums`テーブルを`Singers`テーブルにインターリーブさせる
- `Tracks`テーブルを`Albums`テーブルにインターリーブさせる

これにより、ある`Singer`のデータと、その`Singer`が持つ全ての`Album`、さらに各`Album`が持つ全ての`Track`のデータが、物理的に近いストレージ領域に配置されます。

その結果、**親子関係のデータを`JOIN`する際のパフォーマンスが劇的に向上します。**

### 3. 移行によるアプリケーションコードの変化

CassandraからSpannerへの移行は、単なるデータベースの置き換えではありません。アプリケーションのアーキテクチャそのものをシンプルにします。

- **Before (Cassandra):**
    - 歌手のディスコグラフィ（アルバムと曲のリスト）を取得するために、アプリケーションは複数のクエリを発行する必要がありました。
        1. `Singers`テーブルから歌手情報を取得。
        2. `Albums`テーブルからその歌手のアルバムIDリストを取得。
        3. 各アルバムIDについて、`Tracks`テーブルにクエリを発行して曲情報を取得。
    - アプリケーション（Javaコード）は、これらの結果を全て受け取り、手動でマージして最終的なデータ構造（DTO）を組み立てる必要がありました。これは複雑で、多くのボイラープレートコードを必要とします。

- **After (Spanner):**
    - インターリーブテーブルと`JOIN`のおかげで、**単一のSQLクエリ**で歌手、アルバム、曲の全ての情報を一度に取得できます。
    - データベースがデータの結合を行ってくれるため、アプリケーションはクエリ結果をそのままマッピングするだけで済みます。
    - これにより、**アプリケーションロジックが大幅に簡素化され**、コードの可読性と保守性が向上します。

### まとめ

| 観点 | Cassandra | Spannerへの移行後 |
| :--- | :--- | :--- |
| **データモデル** | 非正規化。クエリごとにテーブルを作成。 | 正規化。RDBのように関連を定義。 |
| **データ取得** | アプリケーションが複数クエリを発行し、手動でデータを結合。 | **単一のSQLクエリ**でデータベースがデータを結合。 |
| **コードの複雑さ** | 高い。データマージのロジックが必要。 | **低い**。クエリ結果をマッピングするだけ。 |
| **データの一貫性**| 結果整合性。アプリ側での考慮が必要な場合も。| **強整合性**。常に一貫したデータを扱える。 |

このハンズオンを通じて、Cassandraの「クエリ駆動・非正規化」モデルから、Spannerの「リレーショナル・正規化・インターリーブ」モデルへのパラダイムシフトを体験できます。そして、その移行が、いかにアプリケーション開発をシンプルかつ堅牢にするかを実感できるでしょう。
